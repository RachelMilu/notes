js 学习笔记 - 秘密花园

变量解析是在代码运行前
赋值是在运行时
this的五种指向
1 全局的this
2 全局里的方法调用
3 对象的方法调用
4 new 出来的对象 的函数里的this
5 a.prototype.call的第一个参数

晚绑定特性 var a = B.C(); a()里面的this不是B 而是全局对象

闭包 循环中的闭包 特别是settimeout中的闭包
匿名包裹器即自执行函数
在settimeout中引用外部函数的属性时，1 可以用自执行函数传参的形式生成一个拷贝 2 在自执行函数中返回一个函数

apply a.apply.（null，argument）等同于 a(argument)

new  如果构造器没有显示地返回 则会隐式的返回this。如果显式的返回一个非对象的玩意儿，则依然返回this。
除非返回自定义对象，但是返回自定义对象不能继承构造器的prototype

工厂模式 即声明一个工厂方法 在该方法里返回新对象 放弃原型链

每次引用一个变量，js会向上遍历整个作用域，直到找到这个变量为止。否则会抛出一个referrenceError。

变量提升 var表达式和function声明都会被提升到当前作用域顶部。 赋值动作在变量提升后面。

匿名函数会被认为是表达式，他们会被先执行。

命名冲突可以用自执行函数解决，自执行函数会创建出新的命名空间。

(function(){}()) == (function(){})()  == +function(){}();

for in 遍历数组，会遍历原型链上的所有属性，会慢。

hasOwnProperty过滤原型链上的属性。

最佳性能是哪个经典的for   for(var i=0;){}

undefined在js中是一个变量

数组字面量是[]

js是弱类型语言 == 会为了比较两个值儿进行强制类型转换， === 严格等于，不做类型转换

typeof运算符 会返回五种类型 string boolean object function number

获取具体哪个class的值 用Object.prototype.toString.call(某个对象)

instanceof 比较两个操作数的构造函数在同上下文中是否一样

‘’ + 10 === ’10'

+’10’ === 10



























 
